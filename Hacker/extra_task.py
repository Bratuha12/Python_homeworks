"""
1) Лабиринт
Дан лабиринт (Матрица NxN) дана точка входа в лабиринт. Стеной является
символ - # коридор - . Например

##########
.........#
######.###
#......###
#.####.###
#........#
##.#######
##.##.####
##......##
#######.##

enter = [1, 0]
exit = ???
Найти выход из лабиринта.
Учтите что лабиринты могут быть самыми разными, разного размера, без выхода и т/д/
"""
# maze = [
#     ['#', '#', '#', '#', '#', '#', '#', '#', '#', '#'],
#     ['.', '.', '.', '.', '.', '.', '.', '.', '.', '#'],
#     ['#', '#', '#', '#', '#', '#', '.', '#', '#', '#'],
#     ['#', '.', '.', '.', '.', '.', '.', '#', '#', '#'],
#     ['#', '.', '#', '#', '#', '#', '.', '#', '#', '#'],
#     ['#', '.', '.', '.', '.', '.', '.', '.', '.', '#'],
#     ['#', '#', '.', '#', '#', '#', '#', '#', '#', '#'],
#     ['#', '#', '.', '#', '#', '.', '#', '#', '#', '#'],
#     ['#', '#', '.', '.', '.', '.', '.', '.', '#', '#'],
#     ['#', '#', '#', '#', '#', '#', '#', '.', '#', '#']
# ]

# maze = [
#     ['#', '#', '#', '#', '#', '#', '#', '#', '#', '#'],
#     ['#', '.', '.', '.', '.', '.', '.', '.', '.', '#'],
#     ['#', '#', '#', '#', '#', '#', '.', '#', '#', '#'],
#     ['.', '.', '.', '.', '.', '.', '.', '#', '#', '#'],
#     ['#', '.', '#', '#', '#', '#', '.', '#', '#', '#'],
#     ['#', '.', '.', '.', '.', '.', '.', '.', '.', '#'],
#     ['#', '#', '.', '#', '#', '#', '#', '#', '#', '#'],
#     ['#', '#', '.', '#', '#', '.', '#', '#', '#', '#'],
#     ['#', '#', '.', '.', '.', '.', '.', '.', '#', '#'],
#     ['#', '#', '#', '#', '#', '#', '#', '#', '#', '#']
# ]

maze = [
    ['#', '.', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#'],
    ['#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#'],
    ['#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '.', '#'],
    ['#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#'],
    ['#', '.', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#'],
    ['#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#'],
    ['#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '.', '#'],
    ['#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#'],
    ['#', '.', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#'],
    ['#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#'],
    ['#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '.', '#']
]

# enter = [1, 0]
# enter = [3, 0]
enter = [10, 10]
exit = []
raw_number = len(maze)
column_number = len(maze[0])


def check_exit(raw, column, n, m):
    """
    Проверка условия выхода из лабиринтаю.
    :param raw: номер строки проверяемого элемента.
    :param column: номер колонки проверяемого элемента.
    :param n: количество строк в матрице.
    :param m: количество колонок в матрице.
    :return: True, если проверяемый элемент находится на внешней границе
    лабиринта.
    """
    if raw == 0 or column == 0 or raw == n - 1 or column == m - 1:
        return True


def make_step(step):
    """
    Создаём функцию только для одного шага, которая сканирует матрицу при помощи
    цикла for. Если находится число, которое соответствует количеству шагов step,
    смотрим на ячейки вокруг и проверяем: нет ли здесь пока еще числа > 0,
    нет ли здесь стены. И ставим step+1 этим ячейкам.
    :param step: порядковый номер шага, по значению которого сканируется матрица.
    :return: возвращает координаты выхода из лабиринта.
    """
    for raw in range(raw_number):
        for column in range(column_number):
            if matrix[raw][column] == step:
                if raw > 0 and matrix[raw - 1][column] == 0 and \
                        maze[raw - 1][column] == '.':
                    matrix[raw - 1][column] = step + 1
                    if check_exit(raw - 1, column, raw_number, column_number):
                        return [raw - 1, column]
                if column > 0 and matrix[raw][column - 1] == 0 and \
                        maze[raw][column - 1] == '.':
                    matrix[raw][column - 1] = step + 1
                    if check_exit(raw, column - 1, raw_number, column_number):
                        return [raw, column - 1]
                if raw < raw_number - 1 and matrix[raw + 1][column] == 0 and \
                        maze[raw + 1][column] == '.':
                    matrix[raw + 1][column] = step + 1
                    if check_exit(raw + 1, column, raw_number, column_number):
                        return [raw + 1, column]
                if column < column_number - 1 and matrix[raw][
                    column + 1] == 0 and maze[raw][column + 1] == '.':
                    matrix[raw][column + 1] = step + 1
                    if check_exit(raw, column + 1, raw_number, column_number):
                        return [raw, column + 1]


# Создаём нулевую матрицу размера NxN (по размерам лабиринта)
matrix = []
for raw in range(raw_number):
    matrix.append([])
    for column in range(column_number):
        matrix[-1].append(0)

matrix[enter[0]][enter[1]] = 1  # определяем начало пути в нулевой матрице

# Заполняем нулевую матрицу до точки выхода. Количество итераций -
# это количество клеток внутри лабиринта (считаем, что внутри стен нет) +
# две клетки входа и выхода.
for step in range(1, (raw_number - 2) * (column_number - 2) + 3):
    exit = make_step(step)
    if exit:
        print(f'Выход найден! Координаты выхода {exit}')
        break
if not exit:
    print('Выход из лабиринта не существует!')

for raw in range(raw_number):
    print(matrix[raw])
